
# FlexNetOS Migration Skeleton

**Date:** 20251004-214916

Offline-first skeleton to migrate toward **single-binary core + WASM components + capability tokens**, orchestrated by a **three-plane** architecture and **tri-sandbox** parallelism (A/B/C â†’ merged Model D).

## Layout

```
orchestrator/
  policies/                   # capability schemas, SLO budgets
  contracts/                  # contract templates/policies
  keys/                       # optional minisign/gpg keys (offline)
contracts/
  inference.capnp             # hot path IDL (example)
  samples/                    # golden requests/responses (binary+json)
execution/
  core/                       # Rust core (skeleton)
  wasm/connector1/            # WASM component 1 (skeleton)
  wasm/connector2/            # WASM component 2 (skeleton)
  policies/                   # runtime policies, ebpf placeholders
  attestation/                # attestation receipts
sandbox/
  inputs/                     # input test files
  tri-sandbox/
    A/run.sh                  # Model A command (replace with real)
    B/run.sh                  # Model B command
    C/run.sh                  # Model C command
    unifier/merge.py          # evolutionary merge -> Model D
  outputs/                    # generated by tri-run
  parent/
    model-D/                  # final merged deliverable candidate
tools/
  sbom_gen.py                 # CycloneDX SBOM generator (minimal)
  signer.py                   # SHA256 manifest + optional minisign
  verify.py                   # verifies manifest + SBOM file hashes
  tri_runner.py               # runs A/B/C in parallel, captures traces
  merkle_anchor.py            # Merkle root over release set
  promote.py                  # promotion with attestation stub
Makefile
```

## Quick start

```bash
cd flexnetos_migration_skeleton
make init
make gen-sbom
make sign
make verify
make contract-test
make tri-run
make merge
make anchor
# optional
make promote
```

- **No Docker.** Pure Python + bash. Cargo is optional for the Rust core.
- **Signing:** If `minisign` is present and a key exists in `orchestrator/keys/minisign.key`, it will be used; otherwise a SHA256 manifest is created and verified.
- **Anchor:** Writes a local file with the Merkle root (ready to broadcast on-chain later).
